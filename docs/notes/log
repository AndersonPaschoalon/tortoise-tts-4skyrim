Yes, it is possible to capture and log all output to stdout (including print statements from your code and messages from external libraries) while still allowing it to be printed to the console. You can achieve this by redirecting the standard output to a custom logging handler.

Here is an example of how you can achieve this in Python:


import logging
import sys

# Set up logging
logger = logging.getLogger('stdout_logger')
logger.setLevel(logging.DEBUG)

# Create file handler for logging
log_file = 'output.log'
file_handler = logging.FileHandler(log_file)
file_handler.setLevel(logging.DEBUG)

# Create stream handler to still print to console
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.DEBUG)

# Create a formatter and set it for both handlers
formatter = logging.Formatter('%(asctime)s - %(message)s')
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# Redirect stdout to the logger
class StdoutLogger:
    def __init__(self, logger):
        self.logger = logger

    def write(self, message):
        if message.strip():  # Avoid logging empty lines
            self.logger.debug(message.strip())

    def flush(self):
        pass  # This flush method is needed for Python 3 compatibility

sys.stdout = StdoutLogger(logger)

# Now any print statements and output from libraries will be logged
print("This is a test message.")
import this  # Example to show library output
In this example:

A logger named stdout_logger is set up with two handlers: one for writing to a file (output.log) and one for printing to the console.
A custom class StdoutLogger is created to redirect stdout to the logger.
The sys.stdout is replaced with an instance of StdoutLogger.
This way, any print statements and output from libraries will be logged to output.log while still being printed to the console.